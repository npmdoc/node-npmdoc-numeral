<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://numeraljs.com">numeral (v2.0.6)</a>
</h1>
<h4>Format and manipulate numbers.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral">module numeral</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral">
            function <span class="apidocSignatureSpan"></span>numeral
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.defaultFormat">
            function <span class="apidocSignatureSpan">numeral.</span>defaultFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.isNumeral">
            function <span class="apidocSignatureSpan">numeral.</span>isNumeral
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.locale">
            function <span class="apidocSignatureSpan">numeral.</span>locale
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.localeData">
            function <span class="apidocSignatureSpan">numeral.</span>localeData
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.nullFormat">
            function <span class="apidocSignatureSpan">numeral.</span>nullFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.register">
            function <span class="apidocSignatureSpan">numeral.</span>register
            <span class="apidocSignatureSpan">(type, name, format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.reset">
            function <span class="apidocSignatureSpan">numeral.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.toString">
            function <span class="apidocSignatureSpan">numeral.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.validate">
            function <span class="apidocSignatureSpan">numeral.</span>validate
            <span class="apidocSignatureSpan">(val, culture)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.zeroFormat">
            function <span class="apidocSignatureSpan">numeral.</span>zeroFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>fn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>formats</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>locales</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">numeral.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral._">module numeral._</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.correctionFactor">
            function <span class="apidocSignatureSpan">numeral._.</span>correctionFactor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.includes">
            function <span class="apidocSignatureSpan">numeral._.</span>includes
            <span class="apidocSignatureSpan">(string, search)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.insert">
            function <span class="apidocSignatureSpan">numeral._.</span>insert
            <span class="apidocSignatureSpan">(string, subString, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.isNaN">
            function <span class="apidocSignatureSpan">numeral._.</span>isNaN
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.multiplier">
            function <span class="apidocSignatureSpan">numeral._.</span>multiplier
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.numberToFormat">
            function <span class="apidocSignatureSpan">numeral._.</span>numberToFormat
            <span class="apidocSignatureSpan">(value, format, roundingFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.reduce">
            function <span class="apidocSignatureSpan">numeral._.</span>reduce
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.stringToNumber">
            function <span class="apidocSignatureSpan">numeral._.</span>stringToNumber
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.toFixed">
            function <span class="apidocSignatureSpan">numeral._.</span>toFixed
            <span class="apidocSignatureSpan">(value, maxDecimals, roundingFunction, optionals)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral.fn">module numeral.fn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.add">
            function <span class="apidocSignatureSpan">numeral.fn.</span>add
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.clone">
            function <span class="apidocSignatureSpan">numeral.fn.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.difference">
            function <span class="apidocSignatureSpan">numeral.fn.</span>difference
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.divide">
            function <span class="apidocSignatureSpan">numeral.fn.</span>divide
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.format">
            function <span class="apidocSignatureSpan">numeral.fn.</span>format
            <span class="apidocSignatureSpan">(inputString, roundingFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.input">
            function <span class="apidocSignatureSpan">numeral.fn.</span>input
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.multiply">
            function <span class="apidocSignatureSpan">numeral.fn.</span>multiply
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.set">
            function <span class="apidocSignatureSpan">numeral.fn.</span>set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.subtract">
            function <span class="apidocSignatureSpan">numeral.fn.</span>subtract
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.value">
            function <span class="apidocSignatureSpan">numeral.fn.</span>value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral" id="apidoc.module.numeral">module numeral</a></h1>


    <h2>
        <a href="#apidoc.element.numeral.numeral" id="apidoc.element.numeral.numeral">
        function <span class="apidocSignatureSpan"></span>numeral
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numeral = function (input) {
    var value,
        kind,
        unformatFunction,
        regexp;

    if (numeral.isNumeral(input)) {
        value = input.value();
    } else if (input === 0 || typeof input === 'undefined') {
        value = 0;
    } else if (input === null || _.isNaN(input)) {
        value = null;
    } else if (typeof input === 'string') {
        if (options.zeroFormat &amp;&amp; input === options.zeroFormat) {
            value = 0;
        } else if (options.nullFormat &amp;&amp; input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
            value = null;
        } else {
            for (kind in formats) {
                regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].
regexps.unformat;

                if (regexp &amp;&amp; input.match(regexp)) {
                    unformatFunction = formats[kind].unformat;

                    break;
                }
            }

            unformatFunction = unformatFunction || numeral._.stringToNumber;

            value = unformatFunction(input);
        }
    } else {
        value = Number(input)|| null;
    }

    return new Numeral(input, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.defaultFormat" id="apidoc.element.numeral.defaultFormat">
        function <span class="apidocSignatureSpan">numeral.</span>defaultFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultFormat = function (format) {
    options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.isNumeral" id="apidoc.element.numeral.isNumeral">
        function <span class="apidocSignatureSpan">numeral.</span>isNumeral
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumeral = function (obj) {
    return obj instanceof Numeral;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.locale" id="apidoc.element.numeral.locale">
        function <span class="apidocSignatureSpan">numeral.</span>locale
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locale = function (key) {
    if (key) {
        options.currentLocale = key.toLowerCase();
    }

    return options.currentLocale;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.localeData" id="apidoc.element.numeral.localeData">
        function <span class="apidocSignatureSpan">numeral.</span>localeData
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localeData = function (key) {
    if (!key) {
        return locales[options.currentLocale];
    }

    key = key.toLowerCase();

    if (!locales[key]) {
        throw new Error('Unknown locale : ' + key);
    }

    return locales[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.nullFormat" id="apidoc.element.numeral.nullFormat">
        function <span class="apidocSignatureSpan">numeral.</span>nullFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullFormat = function (format) {
    options.nullFormat = typeof(format) === 'string' ? format : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.register" id="apidoc.element.numeral.register">
        function <span class="apidocSignatureSpan">numeral.</span>register
        <span class="apidocSignatureSpan">(type, name, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (type, name, format) {
    name = name.toLowerCase();

    if (this[type + 's'][name]) {
        throw new TypeError(name + ' ' + type + ' already registered.');
    }

    this[type + 's'][name] = format;

    return format;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 2.0.0

2.0.0 brings a lot of breaking changes and a reorganization of the repo, but also simplifies the api as well as the creating of
custom formats.

Breaking change / Feature: All formats are now separate files.  This makes it easy to create custom formats, and will also allow
 for custom builds with only certain formats.  (Note: The built numeral.js still contains all formats in the repo).

Breaking change / Feature: All formats and locales are now loaded using `numeral.<span class="apidocCodeKeywordSpan">register</span>(type, name, {})`

Breaking change: All `language` now renamed to `locale` and standardized to all lowercase filenames

Breaking change: The `locale` function no longer loads locales, it only sets the current locale

Breaking change: The `unformat` function has been removed `numeral().unformat(string)` and now happens on numeral init `numeral(
string)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.reset" id="apidoc.element.numeral.reset">
        function <span class="apidocSignatureSpan">numeral.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    for (var property in defaults) {
        options[property] = defaults[property];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.toString" id="apidoc.element.numeral.toString">
        function <span class="apidocSignatureSpan">numeral.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return toString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.validate" id="apidoc.element.numeral.validate">
        function <span class="apidocSignatureSpan">numeral.</span>validate
        <span class="apidocSignatureSpan">(val, culture)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (val, culture) {
    var _decimalSep,
        _thousandSep,
        _currSymbol,
        _valArray,
        _abbrObj,
        _thousandRegEx,
        localeData,
        temp;

    //coerce val to string
    if (typeof val !== 'string') {
        val += '';

        if (console.warn) {
            console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
        }
    }

    //trim whitespaces from either sides
    val = val.trim();

    //if val is just digits return true
    if (!!val.match(/^\d+$/)) {
        return true;
    }

    //if val is empty return false
    if (val === '') {
        return false;
    }

    //get the decimal and thousands separator from numeral.localeData
    try {
        //check if the culture is understood by numeral. if not, default it to current locale
        localeData = numeral.localeData(culture);
    } catch (e) {
        localeData = numeral.localeData(numeral.locale());
    }

    //setup the delimiters and currency symbol based on culture/locale
    _currSymbol = localeData.currency.symbol;
    _abbrObj = localeData.abbreviations;
    _decimalSep = localeData.delimiters.decimal;
    if (localeData.delimiters.thousands === '.') {
        _thousandSep = '\\.';
    } else {
        _thousandSep = localeData.delimiters.thousands;
    }

    // validating currency symbol
    temp = val.match(/^[^\d]+/);
    if (temp !== null) {
        val = val.substr(1);
        if (temp[0] !== _currSymbol) {
            return false;
        }
    }

    //validating abbreviation symbol
    temp = val.match(/[^\d]+$/);
    if (temp !== null) {
        val = val.slice(0, -1);
        if (temp[0] !== _abbrObj.thousand &amp;&amp; temp[0] !== _abbrObj.million &amp;&amp; temp[0] !== _abbrObj.billion &amp;&amp; temp[0] !== _abbrObj
.trillion) {
            return false;
        }
    }

    _thousandRegEx = new RegExp(_thousandSep + '{2}');

    if (!val.match(/[^\d.,]/g)) {
        _valArray = val.split(_decimalSep);
        if (_valArray.length &gt; 2) {
            return false;
        } else {
            if (_valArray.length &lt; 2) {
                return ( !! _valArray[0].match(/^\d+.*\d$/) &amp;&amp; !_valArray[0].match(_thousandRegEx));
            } else {
                if (_valArray[0].length === 1) {
                    return ( !! _valArray[0].match(/^\d+$/) &amp;&amp; !_valArray[0].match(_thousandRegEx) &amp;&amp; !! _valArray[1].match(/^\d
+$/));
                } else {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) &amp;&amp; !_valArray[0].match(_thousandRegEx) &amp;&amp; !! _valArray[1].match(/^\d+$/));
                }
            }
        }
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.zeroFormat" id="apidoc.element.numeral.zeroFormat">
        function <span class="apidocSignatureSpan">numeral.</span>zeroFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroFormat = function (format) {
    options.zeroFormat = typeof(format) === 'string' ? format : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral._" id="apidoc.module.numeral._">module numeral._</a></h1>


    <h2>
        <a href="#apidoc.element.numeral._.correctionFactor" id="apidoc.element.numeral._.correctionFactor">
        function <span class="apidocSignatureSpan">numeral._.</span>correctionFactor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">correctionFactor = function () {
    var args = Array.prototype.slice.call(arguments);

    return args.reduce(function(accum, next) {
        var mn = _.multiplier(next);
        return accum &gt; mn ? accum : mn;
    }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.includes" id="apidoc.element.numeral._.includes">
        function <span class="apidocSignatureSpan">numeral._.</span>includes
        <span class="apidocSignatureSpan">(string, search)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (string, search) {
    return string.indexOf(search) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.insert" id="apidoc.element.numeral._.insert">
        function <span class="apidocSignatureSpan">numeral._.</span>insert
        <span class="apidocSignatureSpan">(string, subString, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (string, subString, start) {
    return string.slice(0, start) + subString + string.slice(start);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.isNaN" id="apidoc.element.numeral._.isNaN">
        function <span class="apidocSignatureSpan">numeral._.</span>isNaN
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function (value) {
    return typeof value === 'number' &amp;&amp; isNaN(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.multiplier" id="apidoc.element.numeral._.multiplier">
        function <span class="apidocSignatureSpan">numeral._.</span>multiplier
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiplier = function (x) {
    var parts = x.toString().split('.');

    return parts.length &lt; 2 ? 1 : Math.pow(10, parts[1].length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.numberToFormat" id="apidoc.element.numeral._.numberToFormat">
        function <span class="apidocSignatureSpan">numeral._.</span>numberToFormat
        <span class="apidocSignatureSpan">(value, format, roundingFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberToFormat = function (value, format, roundingFunction) {
    var locale = locales[numeral.options.currentLocale],
        negP = false,
        optDec = false,
        leadingCount = 0,
        abbr = '',
        trillion = 1000000000000,
        billion = 1000000000,
        million = 1000000,
        thousand = 1000,
        decimal = '',
        neg = false,
        abbrForce, // force abbreviation
        abs,
        min,
        max,
        power,
        int,
        precision,
        signed,
        thousands,
        output;

    // make sure we never format a null value
    value = value || 0;

    abs = Math.abs(value);

    // see if we should use parentheses for negative number or if we should prefix with a sign
    // if both are present we default to parentheses
    if (numeral._.includes(format, '(')) {
        negP = true;
        format = format.replace(/[\(|\)]/g, '');
    } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
        signed = numeral._.includes(format, '+') ? format.indexOf('+') : value &lt; 0 ? format.indexOf('-') : -1;
        format = format.replace(/[\+|\-]/g, '');
    }

    // see if abbreviation is wanted
    if (numeral._.includes(format, 'a')) {
        abbrForce = format.match(/a(k|m|b|t)?/);

        abbrForce = abbrForce ? abbrForce[1] : false;

        // check for space before abbreviation
        if (numeral._.includes(format, ' a')) {
            abbr = ' ';
        }

        format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

        if (abs &gt;= trillion &amp;&amp; !abbrForce || abbrForce === 't') {
            // trillion
            abbr += locale.abbreviations.trillion;
            value = value / trillion;
        } else if (abs &lt; trillion &amp;&amp; abs &gt;= billion &amp;&amp; !abbrForce || abbrForce === 'b') {
            // billion
            abbr += locale.abbreviations.billion;
            value = value / billion;
        } else if (abs &lt; billion &amp;&amp; abs &gt;= million &amp;&amp; !abbrForce || abbrForce === 'm') {
            // million
            abbr += locale.abbreviations.million;
            value = value / million;
        } else if (abs &lt; million &amp;&amp; abs &gt;= thousand &amp;&amp; !abbrForce || abbrForce === 'k') {
            // thousand
            abbr += locale.abbreviations.thousand;
            value = value / thousand;
        }
    }

    // check for optional decimals
    if (numeral._.includes(format, '[.]')) {
        optDec = true;
        format = format.replace('[.]', '.');
    }

    // break number and format
    int = value.toString().split('.')[0];
    precision = format.split('.')[1];
    thousands = format.indexOf(',');
    leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

    if (precision) {
        if (numeral._.includes(precision, '[')) {
            precision = precision.replace(']', '');
            precision = precision.split('[');
            decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length
);
        } else {
            decimal = numeral._.toFixed(value, precision.length, roundingFunction);
        }

        int = decimal.split('.')[0];

        if (numeral._.includes(decimal, '.')) {
            decimal = locale.delimiters.decimal + decimal.split('.')[1];
        } else {
            decimal = '';
        }

        if (optDec &amp;&amp; Number(decimal.slice(1)) === 0) {
            decimal = '';
        }
    } else {
        int = numeral._.toFixed(value, 0, roundingFunction);
    }

    // check abbreviation again after rounding
    if (abbr &amp;&amp; !abbrForce &amp;&amp; Number(int) &gt;= 1000 &amp;&amp; abbr !== locale.abbreviations.trillion) {
        int = String(Number(int) / 1000);

        switch (abbr) {
            case locale.abbreviations.thousand:
                abbr = locale.abbreviations.million;
                break;
            case locale.abbreviations.million:
                abbr = locale.abbreviations.billion;
                break;
            case locale.abbreviations.billion:
                abbr = locale.abbreviations.trillion;
                break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.reduce" id="apidoc.element.numeral._.reduce">
        function <span class="apidocSignatureSpan">numeral._.</span>reduce
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function (array, callback) {
    if (this === null) {
        throw new TypeError('Array.prototype.reduce called on null or undefined');
    }

    if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
    }

    var t = Object(array),
        len = t.length &gt;&gt;&gt; 0,
        k = 0,
        value;

    if (arguments.length === 3) {
        value = arguments[2];
    } else {
        while (k &lt; len &amp;&amp; !(k in t)) {
            k++;
        }

        if (k &gt;= len) {
            throw new TypeError('Reduce of empty array with no initial value');
        }

        value = t[k++];
    }
    for (; k &lt; len; k++) {
        if (k in t) {
            value = callback(value, t[k], k, t);
        }
    }
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.stringToNumber" id="apidoc.element.numeral._.stringToNumber">
        function <span class="apidocSignatureSpan">numeral._.</span>stringToNumber
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringToNumber = function (string) {
    var locale = locales[options.currentLocale],
        stringOriginal = string,
        abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
        },
        abbreviation,
        value,
        i,
        regexp;

    if (options.zeroFormat &amp;&amp; string === options.zeroFormat) {
        value = 0;
    } else if (options.nullFormat &amp;&amp; string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
        value = null;
    } else {
        value = 1;

        if (locale.delimiters.decimal !== '.') {
            string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
        }

        for (abbreviation in abbreviations) {
            regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

            if (stringOriginal.match(regexp)) {
                value *= Math.pow(10, abbreviations[abbreviation]);
                break;
            }
        }

        // check for negative number
        value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

        // remove non numbers
        string = string.replace(/[^0-9\.]+/g, '');

        value *= Number(string);
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.toFixed" id="apidoc.element.numeral._.toFixed">
        function <span class="apidocSignatureSpan">numeral._.</span>toFixed
        <span class="apidocSignatureSpan">(value, maxDecimals, roundingFunction, optionals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFixed = function (value, maxDecimals, roundingFunction, optionals) {
    var splitValue = value.toString().split('.'),
        minDecimals = maxDecimals - (optionals || 0),
        boundedPrecision,
        optionalsRegExp,
        power,
        output;

    // Use the smallest precision value possible to avoid errors from floating point representation
    if (splitValue.length === 2) {
      boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
    } else {
      boundedPrecision = minDecimals;
    }

    power = Math.pow(10, boundedPrecision);

    // Multiply up by precision, round accurately, then divide and use native toFixed():
    output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

    if (optionals &gt; maxDecimals - boundedPrecision) {
        optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
        output = output.replace(optionalsRegExp, '');
    }

    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral.fn" id="apidoc.module.numeral.fn">module numeral.fn</a></h1>


    <h2>
        <a href="#apidoc.element.numeral.fn.add" id="apidoc.element.numeral.fn.add">
        function <span class="apidocSignatureSpan">numeral.fn.</span>add
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (value) {
    var corrFactor = _.correctionFactor.call(null, this._value, value);

    function cback(accum, curr, currI, O) {
        return accum + Math.round(corrFactor * curr);
    }

    this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.clone" id="apidoc.element.numeral.fn.clone">
        function <span class="apidocSignatureSpan">numeral.fn.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
    return numeral(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.difference" id="apidoc.element.numeral.fn.difference">
        function <span class="apidocSignatureSpan">numeral.fn.</span>difference
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">difference = function (value) {
    return Math.abs(numeral(this._value).subtract(value).value());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.divide" id="apidoc.element.numeral.fn.divide">
        function <span class="apidocSignatureSpan">numeral.fn.</span>divide
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divide = function (value) {
    function cback(accum, curr, currI, O) {
        var corrFactor = _.correctionFactor(accum, curr);
        return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
    }

    this._value = _.reduce([this._value, value], cback);

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.format" id="apidoc.element.numeral.fn.format">
        function <span class="apidocSignatureSpan">numeral.fn.</span>format
        <span class="apidocSignatureSpan">(inputString, roundingFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (inputString, roundingFunction) {
    var value = this._value,
        format = inputString || options.defaultFormat,
        kind,
        output,
        formatFunction;

    // make sure we have a roundingFunction
    roundingFunction = roundingFunction || Math.round;

    // format based on value
    if (value === 0 &amp;&amp; options.zeroFormat !== null) {
        output = options.zeroFormat;
    } else if (value === null &amp;&amp; options.nullFormat !== null) {
        output = options.nullFormat;
    } else {
        for (kind in formats) {
            if (format.match(formats[kind].regexps.format)) {
                formatFunction = formats[kind].format;

                break;
            }
        }

        formatFunction = formatFunction || numeral._.numberToFormat;

        output = formatFunction(value, format, roundingFunction);
    }

    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 1.5.1

Bug fix: Make sure values aren't changed during formatting

### 1.5.0

Add defaultFormat(). numeral().<span class="apidocCodeKeywordSpan">format</span>() uses the default to format if no string is provided

.unformat() returns 0 when passed no string

Added languages.js that contains all languages

Bug fix: Fix bug while unformatting ordinals
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.input" id="apidoc.element.numeral.fn.input">
        function <span class="apidocSignatureSpan">numeral.fn.</span>input
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input = function () {
    return this._input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.multiply" id="apidoc.element.numeral.fn.multiply">
        function <span class="apidocSignatureSpan">numeral.fn.</span>multiply
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (value) {
    function cback(accum, curr, currI, O) {
        var corrFactor = _.correctionFactor(accum, curr);
        return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
    }

    this._value = _.reduce([this._value, value], cback, 1);

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.set" id="apidoc.element.numeral.fn.set">
        function <span class="apidocSignatureSpan">numeral.fn.</span>set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (value) {
    this._value = Number(value);

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.subtract" id="apidoc.element.numeral.fn.subtract">
        function <span class="apidocSignatureSpan">numeral.fn.</span>subtract
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (value) {
    var corrFactor = _.correctionFactor.call(null, this._value, value);

    function cback(accum, curr, currI, O) {
        return accum - Math.round(corrFactor * curr);
    }

    this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.value" id="apidoc.element.numeral.fn.value">
        function <span class="apidocSignatureSpan">numeral.fn.</span>value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value = function () {
    return this._value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>