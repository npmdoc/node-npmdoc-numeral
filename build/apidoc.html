<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://numeraljs.com"

    >numeral (v2.0.6)</a>
</h1>
<h4>Format and manipulate numbers.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral">module numeral</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral">
            function <span class="apidocSignatureSpan"></span>numeral
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.defaultFormat">
            function <span class="apidocSignatureSpan">numeral.</span>defaultFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.isNumeral">
            function <span class="apidocSignatureSpan">numeral.</span>isNumeral
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.locale">
            function <span class="apidocSignatureSpan">numeral.</span>locale
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.localeData">
            function <span class="apidocSignatureSpan">numeral.</span>localeData
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.nullFormat">
            function <span class="apidocSignatureSpan">numeral.</span>nullFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.register">
            function <span class="apidocSignatureSpan">numeral.</span>register
            <span class="apidocSignatureSpan">(type, name, format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.reset">
            function <span class="apidocSignatureSpan">numeral.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.validate">
            function <span class="apidocSignatureSpan">numeral.</span>validate
            <span class="apidocSignatureSpan">(val, culture)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.zeroFormat">
            function <span class="apidocSignatureSpan">numeral.</span>zeroFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>fn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>formats</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>locales</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">numeral.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral._">module numeral._</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.correctionFactor">
            function <span class="apidocSignatureSpan">numeral._.</span>correctionFactor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.includes">
            function <span class="apidocSignatureSpan">numeral._.</span>includes
            <span class="apidocSignatureSpan">(string, search)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.insert">
            function <span class="apidocSignatureSpan">numeral._.</span>insert
            <span class="apidocSignatureSpan">(string, subString, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.isNaN">
            function <span class="apidocSignatureSpan">numeral._.</span>isNaN
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.multiplier">
            function <span class="apidocSignatureSpan">numeral._.</span>multiplier
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.numberToFormat">
            function <span class="apidocSignatureSpan">numeral._.</span>numberToFormat
            <span class="apidocSignatureSpan">(value, format, roundingFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.reduce">
            function <span class="apidocSignatureSpan">numeral._.</span>reduce
            <span class="apidocSignatureSpan">(array, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.stringToNumber">
            function <span class="apidocSignatureSpan">numeral._.</span>stringToNumber
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral._.toFixed">
            function <span class="apidocSignatureSpan">numeral._.</span>toFixed
            <span class="apidocSignatureSpan">(value, maxDecimals, roundingFunction, optionals)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral.fn">module numeral.fn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.add">
            function <span class="apidocSignatureSpan">numeral.fn.</span>add
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.clone">
            function <span class="apidocSignatureSpan">numeral.fn.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.difference">
            function <span class="apidocSignatureSpan">numeral.fn.</span>difference
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.divide">
            function <span class="apidocSignatureSpan">numeral.fn.</span>divide
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.format">
            function <span class="apidocSignatureSpan">numeral.fn.</span>format
            <span class="apidocSignatureSpan">(inputString, roundingFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.input">
            function <span class="apidocSignatureSpan">numeral.fn.</span>input
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.multiply">
            function <span class="apidocSignatureSpan">numeral.fn.</span>multiply
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.set">
            function <span class="apidocSignatureSpan">numeral.fn.</span>set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.subtract">
            function <span class="apidocSignatureSpan">numeral.fn.</span>subtract
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.fn.value">
            function <span class="apidocSignatureSpan">numeral.fn.</span>value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.numeral.numeral">module numeral.numeral</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.numeral">
            function <span class="apidocSignatureSpan">numeral.</span>numeral
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.defaultFormat">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>defaultFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.isNumeral">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>isNumeral
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.locale">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>locale
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.localeData">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>localeData
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.nullFormat">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>nullFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.register">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>register
            <span class="apidocSignatureSpan">(type, name, format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.reset">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.validate">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>validate
            <span class="apidocSignatureSpan">(val, culture)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.numeral.numeral.zeroFormat">
            function <span class="apidocSignatureSpan">numeral.numeral.</span>zeroFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.numeral.</span>_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.numeral.</span>fn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.numeral.</span>formats</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.numeral.</span>locales</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">numeral.numeral.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">numeral.numeral.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral" id="apidoc.module.numeral">module numeral</a></h1>


    <h2>
        <a href="#apidoc.element.numeral.numeral" id="apidoc.element.numeral.numeral">
        function <span class="apidocSignatureSpan"></span>numeral
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numeral = function (input) {
    var value,
        kind,
        unformatFunction,
        regexp;

    if (numeral.isNumeral(input)) {
        value = input.value();
    } else if (input === 0 || typeof input === &#x27;undefined&#x27;) {
        value = 0;
    } else if (input === null || _.isNaN(input)) {
        value = null;
    } else if (typeof input === &#x27;string&#x27;) {
        if (options.zeroFormat &#x26;&#x26; input === options.zeroFormat) {
            value = 0;
        } else if (options.nullFormat &#x26;&#x26; input === options.nullFormat || !input.replace(/[^0-9]+/g, &#x27;&#x27;).length) {
            value = null;
        } else {
            for (kind in formats) {
                regexp = typeof formats[kind].regexps.unformat === &#x27;function&#x27; ? formats[kind].regexps.unformat() : formats[kind].
regexps.unformat;

                if (regexp &#x26;&#x26; input.match(regexp)) {
                    unformatFunction = formats[kind].unformat;

                    break;
                }
            }

            unformatFunction = unformatFunction || numeral._.stringToNumber;

            value = unformatFunction(input);
        }
    } else {
        value = Number(input)|| null;
    }

    return new Numeral(input, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.defaultFormat" id="apidoc.element.numeral.defaultFormat">
        function <span class="apidocSignatureSpan">numeral.</span>defaultFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultFormat = function (format) {
    options.defaultFormat = typeof(format) === &#x27;string&#x27; ? format : &#x27;0.0&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.isNumeral" id="apidoc.element.numeral.isNumeral">
        function <span class="apidocSignatureSpan">numeral.</span>isNumeral
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumeral = function (obj) {
    return obj instanceof Numeral;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    numeral = function(input) {
var value,
    kind,
    unformatFunction,
    regexp;

if (numeral.<span class="apidocCodeKeywordSpan">isNumeral</span>(input)) {
    value = input.value();
} else if (input === 0 || typeof input === &#x27;undefined&#x27;) {
    value = 0;
} else if (input === null || _.isNaN(input)) {
    value = null;
} else if (typeof input === &#x27;string&#x27;) {
    if (options.zeroFormat &#x26;&#x26; input === options.zeroFormat) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.locale" id="apidoc.element.numeral.locale">
        function <span class="apidocSignatureSpan">numeral.</span>locale
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locale = function (key) {
    if (key) {
        options.currentLocale = key.toLowerCase();
    }

    return options.currentLocale;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

//get the decimal and thousands separator from numeral.localeData
try {
    //check if the culture is understood by numeral. if not, default it to current locale
    localeData = numeral.localeData(culture);
} catch (e) {
    localeData = numeral.localeData(numeral.<span class="apidocCodeKeywordSpan">locale</span>());
}

//setup the delimiters and currency symbol based on culture/locale
_currSymbol = localeData.currency.symbol;
_abbrObj = localeData.abbreviations;
_decimalSep = localeData.delimiters.decimal;
if (localeData.delimiters.thousands === &#x27;.&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.localeData" id="apidoc.element.numeral.localeData">
        function <span class="apidocSignatureSpan">numeral.</span>localeData
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localeData = function (key) {
    if (!key) {
        return locales[options.currentLocale];
    }

    key = key.toLowerCase();

    if (!locales[key]) {
        throw new Error(&#x27;Unknown locale : &#x27; + key);
    }

    return locales[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (val === &#x27;&#x27;) {
    return false;
}

//get the decimal and thousands separator from numeral.localeData
try {
    //check if the culture is understood by numeral. if not, default it to current locale
    localeData = numeral.<span class="apidocCodeKeywordSpan">localeData</span>(culture);
} catch (e) {
    localeData = numeral.localeData(numeral.locale());
}

//setup the delimiters and currency symbol based on culture/locale
_currSymbol = localeData.currency.symbol;
_abbrObj = localeData.abbreviations;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.nullFormat" id="apidoc.element.numeral.nullFormat">
        function <span class="apidocSignatureSpan">numeral.</span>nullFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullFormat = function (format) {
    options.nullFormat = typeof(format) === &#x27;string&#x27; ? format : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.register" id="apidoc.element.numeral.register">
        function <span class="apidocSignatureSpan">numeral.</span>register
        <span class="apidocSignatureSpan">(type, name, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (type, name, format) {
    name = name.toLowerCase();

    if (this[type + &#x27;s&#x27;][name]) {
        throw new TypeError(name + &#x27; &#x27; + type + &#x27; already registered.&#x27;);
    }

    this[type + &#x27;s&#x27;][name] = format;

    return format;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 2.0.0

2.0.0 brings a lot of breaking changes and a reorganization of the repo, but also simplifies the api as well as the creating of
custom formats.

Breaking change / Feature: All formats are now separate files.  This makes it easy to create custom formats, and will also allow
 for custom builds with only certain formats.  (Note: The built numeral.js still contains all formats in the repo).

Breaking change / Feature: All formats and locales are now loaded using `numeral.<span class="apidocCodeKeywordSpan">register</span
>(type, name, {})`

Breaking change: All `language` now renamed to `locale` and standardized to all lowercase filenames

Breaking change: The `locale` function no longer loads locales, it only sets the current locale

Breaking change: The `unformat` function has been removed `numeral().unformat(string)` and now happens on numeral init `numeral(
string)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.reset" id="apidoc.element.numeral.reset">
        function <span class="apidocSignatureSpan">numeral.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    for (var property in defaults) {
        options[property] = defaults[property];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.validate" id="apidoc.element.numeral.validate">
        function <span class="apidocSignatureSpan">numeral.</span>validate
        <span class="apidocSignatureSpan">(val, culture)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (val, culture) {
    var _decimalSep,
        _thousandSep,
        _currSymbol,
        _valArray,
        _abbrObj,
        _thousandRegEx,
        localeData,
        temp;

    //coerce val to string
    if (typeof val !== &#x27;string&#x27;) {
        val += &#x27;&#x27;;

        if (console.warn) {
            console.warn(&#x27;Numeral.js: Value is not string. It has been co-erced to: &#x27;, val);
        }
    }

    //trim whitespaces from either sides
    val = val.trim();

    //if val is just digits return true
    if (!!val.match(/^\d+$/)) {
        return true;
    }

    //if val is empty return false
    if (val === &#x27;&#x27;) {
        return false;
    }

    //get the decimal and thousands separator from numeral.localeData
    try {
        //check if the culture is understood by numeral. if not, default it to current locale
        localeData = numeral.localeData(culture);
    } catch (e) {
        localeData = numeral.localeData(numeral.locale());
    }

    //setup the delimiters and currency symbol based on culture/locale
    _currSymbol = localeData.currency.symbol;
    _abbrObj = localeData.abbreviations;
    _decimalSep = localeData.delimiters.decimal;
    if (localeData.delimiters.thousands === &#x27;.&#x27;) {
        _thousandSep = &#x27;\\.&#x27;;
    } else {
        _thousandSep = localeData.delimiters.thousands;
    }

    // validating currency symbol
    temp = val.match(/^[^\d]+/);
    if (temp !== null) {
        val = val.substr(1);
        if (temp[0] !== _currSymbol) {
            return false;
        }
    }

    //validating abbreviation symbol
    temp = val.match(/[^\d]+$/);
    if (temp !== null) {
        val = val.slice(0, -1);
        if (temp[0] !== _abbrObj.thousand &#x26;&#x26; temp[0] !== _abbrObj.million &#x26;&#x26; temp[0] !== _abbrObj.billion &#x26;&#x26; temp[0] !== _abbrObj
.trillion) {
            return false;
        }
    }

    _thousandRegEx = new RegExp(_thousandSep + &#x27;{2}&#x27;);

    if (!val.match(/[^\d.,]/g)) {
        _valArray = val.split(_decimalSep);
        if (_valArray.length &#x3e; 2) {
            return false;
        } else {
            if (_valArray.length &#x3c; 2) {
                return ( !! _valArray[0].match(/^\d+.*\d$/) &#x26;&#x26; !_valArray[0].match(_thousandRegEx));
            } else {
                if (_valArray[0].length === 1) {
                    return ( !! _valArray[0].match(/^\d+$/) &#x26;&#x26; !_valArray[0].match(_thousandRegEx) &#x26;&#x26; !! _valArray[1].match(/^\d
+$/));
                } else {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) &#x26;&#x26; !_valArray[0].match(_thousandRegEx) &#x26;&#x26; !! _valArray[1].match(/^\d+$/));
                }
            }
        }
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.zeroFormat" id="apidoc.element.numeral.zeroFormat">
        function <span class="apidocSignatureSpan">numeral.</span>zeroFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroFormat = function (format) {
    options.zeroFormat = typeof(format) === &#x27;string&#x27; ? format : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral._" id="apidoc.module.numeral._">module numeral._</a></h1>


    <h2>
        <a href="#apidoc.element.numeral._.correctionFactor" id="apidoc.element.numeral._.correctionFactor">
        function <span class="apidocSignatureSpan">numeral._.</span>correctionFactor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">correctionFactor = function () {
    var args = Array.prototype.slice.call(arguments);

    return args.reduce(function(accum, next) {
        var mn = _.multiplier(next);
        return accum &#x3e; mn ? accum : mn;
    }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

    return this;
},
multiply: function(value) {
    function cback(accum, curr, currI, O) {
        var corrFactor = _.<span class="apidocCodeKeywordSpan">correctionFactor</span>(accum, curr);
        return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
    }

    this._value = _.reduce([this._value, value], cback, 1);

    return this;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.includes" id="apidoc.element.numeral._.includes">
        function <span class="apidocSignatureSpan">numeral._.</span>includes
        <span class="apidocSignatureSpan">(string, search)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (string, search) {
    return string.indexOf(search) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// make sure we never format a null value
value = value || 0;

abs = Math.abs(value);

// see if we should use parentheses for negative number or if we should prefix with a sign
// if both are present we default to parentheses
if (numeral._.<span class="apidocCodeKeywordSpan">includes</span>(format, &#x27;(&#x27;)) {
    negP = true;
    format = format.replace(/[\(|\)]/g, &#x27;&#x27;);
} else if (numeral._.includes(format, &#x27;+&#x27;) || numeral._.includes(format, &#x27;-&#x27;)) {
    signed = numeral._.includes(format, &#x27;+&#x27;) ? format.indexOf(&#x27;+&#x27;) : value &#x3c; 0 ? format.indexOf(&#x27;-&#
x27;) : -1;
    format = format.replace(/[\+|\-]/g, &#x27;&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.insert" id="apidoc.element.numeral._.insert">
        function <span class="apidocSignatureSpan">numeral._.</span>insert
        <span class="apidocSignatureSpan">(string, subString, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (string, subString, start) {
    return string.slice(0, start) + subString + string.slice(start);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// loop through each before symbol
for (i = 0; i &#x3c; symbols.before.length; i++) {
    symbol = symbols.before[i];

    switch (symbol) {
        case &#x27;$&#x27;:
            output = numeral._.<span class="apidocCodeKeywordSpan">insert</span>(output, locale.currency.symbol, i);
            break;
        case &#x27; &#x27;:
            output = numeral._.insert(output, &#x27; &#x27;, i + locale.currency.symbol.length - 1);
            break;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.isNaN" id="apidoc.element.numeral._.isNaN">
        function <span class="apidocSignatureSpan">numeral._.</span>isNaN
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function (value) {
    return typeof value === &#x27;number&#x27; &#x26;&#x26; isNaN(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    unformatFunction,
    regexp;

if (numeral.isNumeral(input)) {
    value = input.value();
} else if (input === 0 || typeof input === &#x27;undefined&#x27;) {
    value = 0;
} else if (input === null || _.<span class="apidocCodeKeywordSpan">isNaN</span>(input)) {
    value = null;
} else if (typeof input === &#x27;string&#x27;) {
    if (options.zeroFormat &#x26;&#x26; input === options.zeroFormat) {
        value = 0;
    } else if (options.nullFormat &#x26;&#x26; input === options.nullFormat || !input.replace(/[^0-9]+/g, &#x27;&#x27;).length) {
        value = null;
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.multiplier" id="apidoc.element.numeral._.multiplier">
        function <span class="apidocSignatureSpan">numeral._.</span>multiplier
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiplier = function (x) {
    var parts = x.toString().split(&#x27;.&#x27;);

    return parts.length &#x3c; 2 ? 1 : Math.pow(10, parts[1].length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * multiplier that must be used to normalize an operation involving
 * all of them.
 */
correctionFactor: function () {
    var args = Array.prototype.slice.call(arguments);

    return args.reduce(function(accum, next) {
        var mn = _.<span class="apidocCodeKeywordSpan">multiplier</span>(next);
        return accum &#x3e; mn ? accum : mn;
    }, 1);
},
/**
 * Implementation of toFixed() that treats floats more like decimals
 *
 * Fixes binary rounding issues (eg. (0.615).toFixed(2) === &#x27;0.61&#x27;) that present
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.numberToFormat" id="apidoc.element.numeral._.numberToFormat">
        function <span class="apidocSignatureSpan">numeral._.</span>numberToFormat
        <span class="apidocSignatureSpan">(value, format, roundingFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberToFormat = function (value, format, roundingFunction) {
    var locale = locales[numeral.options.currentLocale],
        negP = false,
        optDec = false,
        leadingCount = 0,
        abbr = &#x27;&#x27;,
        trillion = 1000000000000,
        billion = 1000000000,
        million = 1000000,
        thousand = 1000,
        decimal = &#x27;&#x27;,
        neg = false,
        abbrForce, // force abbreviation
        abs,
        min,
        max,
        power,
        int,
        precision,
        signed,
        thousands,
        output;

    // make sure we never format a null value
    value = value || 0;

    abs = Math.abs(value);

    // see if we should use parentheses for negative number or if we should prefix with a sign
    // if both are present we default to parentheses
    if (numeral._.includes(format, &#x27;(&#x27;)) {
        negP = true;
        format = format.replace(/[\(|\)]/g, &#x27;&#x27;);
    } else if (numeral._.includes(format, &#x27;+&#x27;) || numeral._.includes(format, &#x27;-&#x27;)) {
        signed = numeral._.includes(format, &#x27;+&#x27;) ? format.indexOf(&#x27;+&#x27;) : value &#x3c; 0 ? format.indexOf(&#x27;-&#x27;) : -1;
        format = format.replace(/[\+|\-]/g, &#x27;&#x27;);
    }

    // see if abbreviation is wanted
    if (numeral._.includes(format, &#x27;a&#x27;)) {
        abbrForce = format.match(/a(k|m|b|t)?/);

        abbrForce = abbrForce ? abbrForce[1] : false;

        // check for space before abbreviation
        if (numeral._.includes(format, &#x27; a&#x27;)) {
            abbr = &#x27; &#x27;;
        }

        format = format.replace(new RegExp(abbr + &#x27;a[kmbt]?&#x27;), &#x27;&#x27;);

        if (abs &#x3e;= trillion &#x26;&#x26; !abbrForce || abbrForce === &#x27;t&#x27;) {
            // trillion
            abbr += locale.abbreviations.trillion;
            value = value / trillion;
        } else if (abs &#x3c; trillion &#x26;&#x26; abs &#x3e;= billion &#x26;&#x26; !abbrForce || abbrForce === &#x27;b&#x27;) {
            // billion
            abbr += locale.abbreviations.billion;
            value = value / billion;
        } else if (abs &#x3c; billion &#x26;&#x26; abs &#x3e;= million &#x26;&#x26; !abbrForce || abbrForce === &#x27;m&#x27;) {
            // million
            abbr += locale.abbreviations.million;
            value = value / million;
        } else if (abs &#x3c; million &#x26;&#x26; abs &#x3e;= thousand &#x26;&#x26; !abbrForce || abbrForce === &#x27;k&#x27;) {
            // thousand
            abbr += locale.abbreviations.thousand;
            value = value / thousand;
        }
    }

    // check for optional decimals
    if (numeral._.includes(format, &#x27;[.]&#x27;)) {
        optDec = true;
        format = format.replace(&#x27;[.]&#x27;, &#x27;.&#x27;);
    }

    // break number and format
    int = value.toString().split(&#x27;.&#x27;)[0];
    precision = format.split(&#x27;.&#x27;)[1];
    thousands = format.indexOf(&#x27;,&#x27;);
    leadingCount = (format.split(&#x27;.&#x27;)[0].split(&#x27;,&#x27;)[0].match(/0/g) || []).length;

    if (precision) {
        if (numeral._.includes(precision, &#x27;[&#x27;)) {
            precision = precision.replace(&#x27;]&#x27;, &#x27;&#x27;);
            precision = precision.split(&#x27;[&#x27;);
            decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length
);
        } else {
            decimal = numeral._.toFixed(value, precision.length, roundingFunction);
        }

        int = decimal.split(&#x27;.&#x27;)[0];

        if (numeral._.includes(decimal, &#x27;.&#x27;)) {
            decimal = locale.delimiters.decimal + decimal.split(&#x27;.&#x27;)[1];
        } else {
            decimal = &#x27;&#x27;;
        }

        if (optDec &#x26;&#x26; Number(decimal.slice(1)) === 0) {
            decimal = &#x27;&#x27;;
        }
    } else {
        int = numeral._.toFixed(value, 0, roundingFunction);
    }

    // check abbreviation again after rounding
    if (abbr &#x26;&#x26; !abbrForce &#x26;&#x26; Number(int) &#x3e;= 1000 &#x26;&#x26; abbr !== locale.abbreviations.trillion) {
        int = String(Number(int) / 1000);

        switch (abbr) {
            case locale.abbreviations.thousand:
                abbr = locale.abbreviations.million;
                break;
            case locale.abbreviations.million:
                abbr = locale.abbreviations.billion;
                break;
            case locale.abbreviations.billion:
                abbr = locale.abbreviations.trillion;
                break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
output;

                value = value * 10000;

                // check for space before BPS
                format = format.replace(/\s?BPS/, &#x27;&#x27;);

                output = numeral._.<span class="apidocCodeKeywordSpan">numberToFormat</span>(value, format, roundingFunction);

                if (numeral._.includes(output, &#x27;)&#x27;)) {
output = output.split(&#x27;&#x27;);

output.splice(-1, 0, space + &#x27;BPS&#x27;);

output = output.join(&#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.reduce" id="apidoc.element.numeral._.reduce">
        function <span class="apidocSignatureSpan">numeral._.</span>reduce
        <span class="apidocSignatureSpan">(array, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function (array, callback) {
    if (this === null) {
        throw new TypeError(&#x27;Array.prototype.reduce called on null or undefined&#x27;);
    }

    if (typeof callback !== &#x27;function&#x27;) {
        throw new TypeError(callback + &#x27; is not a function&#x27;);
    }

    var t = Object(array),
        len = t.length &#x3e;&#x3e;&#x3e; 0,
        k = 0,
        value;

    if (arguments.length === 3) {
        value = arguments[2];
    } else {
        while (k &#x3c; len &#x26;&#x26; !(k in t)) {
            k++;
        }

        if (k &#x3e;= len) {
            throw new TypeError(&#x27;Reduce of empty array with no initial value&#x27;);
        }

        value = t[k++];
    }
    for (; k &#x3c; len; k++) {
        if (k in t) {
            value = callback(value, t[k], k, t);
        }
    }
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Given a variable number of arguments, returns the maximum
 * multiplier that must be used to normalize an operation involving
 * all of them.
 */
correctionFactor: function () {
    var args = Array.prototype.slice.call(arguments);

    return args.<span class="apidocCodeKeywordSpan">reduce</span>(function(accum, next) {
        var mn = _.multiplier(next);
        return accum &#x3e; mn ? accum : mn;
    }, 1);
},
/**
 * Implementation of toFixed() that treats floats more like decimals
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.stringToNumber" id="apidoc.element.numeral._.stringToNumber">
        function <span class="apidocSignatureSpan">numeral._.</span>stringToNumber
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringToNumber = function (string) {
    var locale = locales[options.currentLocale],
        stringOriginal = string,
        abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
        },
        abbreviation,
        value,
        i,
        regexp;

    if (options.zeroFormat &#x26;&#x26; string === options.zeroFormat) {
        value = 0;
    } else if (options.nullFormat &#x26;&#x26; string === options.nullFormat || !string.replace(/[^0-9]+/g, &#x27;&#x27;).length) {
        value = null;
    } else {
        value = 1;

        if (locale.delimiters.decimal !== &#x27;.&#x27;) {
            string = string.replace(/\./g, &#x27;&#x27;).replace(locale.delimiters.decimal, &#x27;.&#x27;);
        }

        for (abbreviation in abbreviations) {
            regexp = new RegExp(&#x27;[^a-zA-Z]&#x27; + locale.abbreviations[abbreviation] + &#x27;(?:\\)|(\\&#x27; + locale.currency.symbol + &#x27;)?(?:\\))?)?$&#x27;);

            if (stringOriginal.match(regexp)) {
                value *= Math.pow(10, abbreviations[abbreviation]);
                break;
            }
        }

        // check for negative number
        value *= (string.split(&#x27;-&#x27;).length + Math.min(string.split(&#x27;(&#x27;).length - 1, string.split(&#x27;)&#x27;).length - 1)) % 2 ? 1 : -1;

        // remove non numbers
        string = string.replace(/[^0-9\.]+/g, &#x27;&#x27;);

        value *= Number(string);
    }

    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                } else {
                    output = output + space + &#x27;BPS&#x27;;
                }

                return output;
            },
            unformat: function(string) {
                return +(numeral._.<span class="apidocCodeKeywordSpan">stringToNumber</span>(string) * 0.0001).toFixed(15);
            }
        });
}));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral._.toFixed" id="apidoc.element.numeral._.toFixed">
        function <span class="apidocSignatureSpan">numeral._.</span>toFixed
        <span class="apidocSignatureSpan">(value, maxDecimals, roundingFunction, optionals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFixed = function (value, maxDecimals, roundingFunction, optionals) {
    var splitValue = value.toString().split(&#x27;.&#x27;),
        minDecimals = maxDecimals - (optionals || 0),
        boundedPrecision,
        optionalsRegExp,
        power,
        output;

    // Use the smallest precision value possible to avoid errors from floating point representation
    if (splitValue.length === 2) {
      boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
    } else {
      boundedPrecision = minDecimals;
    }

    power = Math.pow(10, boundedPrecision);

    // Multiply up by precision, round accurately, then divide and use native toFixed():
    output = (roundingFunction(value + &#x27;e+&#x27; + boundedPrecision) / power).toFixed(boundedPrecision);

    if (optionals &#x3e; maxDecimals - boundedPrecision) {
        optionalsRegExp = new RegExp(&#x27;\\.?0{1,&#x27; + (optionals - (maxDecimals - boundedPrecision)) + &#x27;}$&#x27;);
        output = output.replace(optionalsRegExp, &#x27;&#x27;);
    }

    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            thousands = format.indexOf(&#x27;,&#x27;);
            leadingCount = (format.split(&#x27;.&#x27;)[0].split(&#x27;,&#x27;)[0].match(/0/g) || []).length;

            if (precision) {
if (numeral._.includes(precision, &#x27;[&#x27;)) {
    precision = precision.replace(&#x27;]&#x27;, &#x27;&#x27;);
    precision = precision.split(&#x27;[&#x27;);
    decimal = numeral._.<span class="apidocCodeKeywordSpan">toFixed</span>(value, (precision[0].length + precision[1].length), roundingFunction
, precision[1].length);
} else {
    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
}

int = decimal.split(&#x27;.&#x27;)[0];

if (numeral._.includes(decimal, &#x27;.&#x27;)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral.fn" id="apidoc.module.numeral.fn">module numeral.fn</a></h1>


    <h2>
        <a href="#apidoc.element.numeral.fn.add" id="apidoc.element.numeral.fn.add">
        function <span class="apidocSignatureSpan">numeral.fn.</span>add
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (value) {
    var corrFactor = _.correctionFactor.call(null, this._value, value);

    function cback(accum, curr, currI, O) {
        return accum + Math.round(corrFactor * curr);
    }

    this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.clone" id="apidoc.element.numeral.fn.clone">
        function <span class="apidocSignatureSpan">numeral.fn.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
    return numeral(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.difference" id="apidoc.element.numeral.fn.difference">
        function <span class="apidocSignatureSpan">numeral.fn.</span>difference
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">difference = function (value) {
    return Math.abs(numeral(this._value).subtract(value).value());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.divide" id="apidoc.element.numeral.fn.divide">
        function <span class="apidocSignatureSpan">numeral.fn.</span>divide
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divide = function (value) {
    function cback(accum, curr, currI, O) {
        var corrFactor = _.correctionFactor(accum, curr);
        return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
    }

    this._value = _.reduce([this._value, value], cback);

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.format" id="apidoc.element.numeral.fn.format">
        function <span class="apidocSignatureSpan">numeral.fn.</span>format
        <span class="apidocSignatureSpan">(inputString, roundingFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (inputString, roundingFunction) {
    var value = this._value,
        format = inputString || options.defaultFormat,
        kind,
        output,
        formatFunction;

    // make sure we have a roundingFunction
    roundingFunction = roundingFunction || Math.round;

    // format based on value
    if (value === 0 &#x26;&#x26; options.zeroFormat !== null) {
        output = options.zeroFormat;
    } else if (value === null &#x26;&#x26; options.nullFormat !== null) {
        output = options.nullFormat;
    } else {
        for (kind in formats) {
            if (format.match(formats[kind].regexps.format)) {
                formatFunction = formats[kind].format;

                break;
            }
        }

        formatFunction = formatFunction || numeral._.numberToFormat;

        output = formatFunction(value, format, roundingFunction);
    }

    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 1.5.1

Bug fix: Make sure values aren&#x27;t changed during formatting

### 1.5.0

Add defaultFormat(). numeral().<span class="apidocCodeKeywordSpan">format</span>() uses the default to format if no string is provided

.unformat() returns 0 when passed no string

Added languages.js that contains all languages

Bug fix: Fix bug while unformatting ordinals
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.input" id="apidoc.element.numeral.fn.input">
        function <span class="apidocSignatureSpan">numeral.fn.</span>input
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input = function () {
    return this._input;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.multiply" id="apidoc.element.numeral.fn.multiply">
        function <span class="apidocSignatureSpan">numeral.fn.</span>multiply
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (value) {
    function cback(accum, curr, currI, O) {
        var corrFactor = _.correctionFactor(accum, curr);
        return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
    }

    this._value = _.reduce([this._value, value], cback, 1);

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.set" id="apidoc.element.numeral.fn.set">
        function <span class="apidocSignatureSpan">numeral.fn.</span>set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (value) {
    this._value = Number(value);

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        platform: &#x27;Windows 10&#x27;
    }
};

process.env.SAUCE_USERNAME = &#x27;numeraljs&#x27;;
process.env.SAUCE_ACCESS_KEY = &#x27;5506968c-cfdc-4797-ba75-294620ad475f&#x27;;

config.<span class="apidocCodeKeywordSpan">set</span>({
    reporters: [
        &#x27;mocha&#x27;,
        &#x27;saucelabs&#x27;
    ],
    browserDisconnectTimeout : 10000,
    browserNoActivityTimeout: 120000,
    browserDisconnectTolerance : 1,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.subtract" id="apidoc.element.numeral.fn.subtract">
        function <span class="apidocSignatureSpan">numeral.fn.</span>subtract
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (value) {
    var corrFactor = _.correctionFactor.call(null, this._value, value);

    function cback(accum, curr, currI, O) {
        return accum - Math.round(corrFactor * curr);
    }

    this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        this._value = _.reduce([this._value, value], cback);

        return this;
    },
    difference: function(value) {
        return Math.abs(numeral(this._value).<span class="apidocCodeKeywordSpan">subtract</span>(value).value());
    }
};

/************************************
    Default Locale &#x26;&#x26; Format
************************************/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.fn.value" id="apidoc.element.numeral.fn.value">
        function <span class="apidocSignatureSpan">numeral.fn.</span>value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value = function () {
    return this._value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    numeral = function(input) {
var value,
    kind,
    unformatFunction,
    regexp;

if (numeral.isNumeral(input)) {
    value = input.<span class="apidocCodeKeywordSpan">value</span>();
} else if (input === 0 || typeof input === &#x27;undefined&#x27;) {
    value = 0;
} else if (input === null || _.isNaN(input)) {
    value = null;
} else if (typeof input === &#x27;string&#x27;) {
    if (options.zeroFormat &#x26;&#x26; input === options.zeroFormat) {
        value = 0;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.numeral.numeral" id="apidoc.module.numeral.numeral">module numeral.numeral</a></h1>


    <h2>
        <a href="#apidoc.element.numeral.numeral.numeral" id="apidoc.element.numeral.numeral.numeral">
        function <span class="apidocSignatureSpan">numeral.</span>numeral
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numeral = function (input) {
    var value,
        kind,
        unformatFunction,
        regexp;

    if (numeral.isNumeral(input)) {
        value = input.value();
    } else if (input === 0 || typeof input === &#x27;undefined&#x27;) {
        value = 0;
    } else if (input === null || _.isNaN(input)) {
        value = null;
    } else if (typeof input === &#x27;string&#x27;) {
        if (options.zeroFormat &#x26;&#x26; input === options.zeroFormat) {
            value = 0;
        } else if (options.nullFormat &#x26;&#x26; input === options.nullFormat || !input.replace(/[^0-9]+/g, &#x27;&#x27;).length) {
            value = null;
        } else {
            for (kind in formats) {
                regexp = typeof formats[kind].regexps.unformat === &#x27;function&#x27; ? formats[kind].regexps.unformat() : formats[kind].
regexps.unformat;

                if (regexp &#x26;&#x26; input.match(regexp)) {
                    unformatFunction = formats[kind].unformat;

                    break;
                }
            }

            unformatFunction = unformatFunction || numeral._.stringToNumber;

            value = unformatFunction(input);
        }
    } else {
        value = Number(input)|| null;
    }

    return new Numeral(input, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.defaultFormat" id="apidoc.element.numeral.numeral.defaultFormat">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>defaultFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultFormat = function (format) {
    options.defaultFormat = typeof(format) === &#x27;string&#x27; ? format : &#x27;0.0&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.isNumeral" id="apidoc.element.numeral.numeral.isNumeral">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>isNumeral
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumeral = function (obj) {
    return obj instanceof Numeral;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    numeral = function(input) {
var value,
    kind,
    unformatFunction,
    regexp;

if (numeral.<span class="apidocCodeKeywordSpan">isNumeral</span>(input)) {
    value = input.value();
} else if (input === 0 || typeof input === &#x27;undefined&#x27;) {
    value = 0;
} else if (input === null || _.isNaN(input)) {
    value = null;
} else if (typeof input === &#x27;string&#x27;) {
    if (options.zeroFormat &#x26;&#x26; input === options.zeroFormat) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.locale" id="apidoc.element.numeral.numeral.locale">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>locale
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locale = function (key) {
    if (key) {
        options.currentLocale = key.toLowerCase();
    }

    return options.currentLocale;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

//get the decimal and thousands separator from numeral.localeData
try {
    //check if the culture is understood by numeral. if not, default it to current locale
    localeData = numeral.localeData(culture);
} catch (e) {
    localeData = numeral.localeData(numeral.<span class="apidocCodeKeywordSpan">locale</span>());
}

//setup the delimiters and currency symbol based on culture/locale
_currSymbol = localeData.currency.symbol;
_abbrObj = localeData.abbreviations;
_decimalSep = localeData.delimiters.decimal;
if (localeData.delimiters.thousands === &#x27;.&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.localeData" id="apidoc.element.numeral.numeral.localeData">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>localeData
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localeData = function (key) {
    if (!key) {
        return locales[options.currentLocale];
    }

    key = key.toLowerCase();

    if (!locales[key]) {
        throw new Error(&#x27;Unknown locale : &#x27; + key);
    }

    return locales[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (val === &#x27;&#x27;) {
    return false;
}

//get the decimal and thousands separator from numeral.localeData
try {
    //check if the culture is understood by numeral. if not, default it to current locale
    localeData = numeral.<span class="apidocCodeKeywordSpan">localeData</span>(culture);
} catch (e) {
    localeData = numeral.localeData(numeral.locale());
}

//setup the delimiters and currency symbol based on culture/locale
_currSymbol = localeData.currency.symbol;
_abbrObj = localeData.abbreviations;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.nullFormat" id="apidoc.element.numeral.numeral.nullFormat">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>nullFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullFormat = function (format) {
    options.nullFormat = typeof(format) === &#x27;string&#x27; ? format : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.register" id="apidoc.element.numeral.numeral.register">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>register
        <span class="apidocSignatureSpan">(type, name, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (type, name, format) {
    name = name.toLowerCase();

    if (this[type + &#x27;s&#x27;][name]) {
        throw new TypeError(name + &#x27; &#x27; + type + &#x27; already registered.&#x27;);
    }

    this[type + &#x27;s&#x27;][name] = format;

    return format;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 2.0.0

2.0.0 brings a lot of breaking changes and a reorganization of the repo, but also simplifies the api as well as the creating of
custom formats.

Breaking change / Feature: All formats are now separate files.  This makes it easy to create custom formats, and will also allow
 for custom builds with only certain formats.  (Note: The built numeral.js still contains all formats in the repo).

Breaking change / Feature: All formats and locales are now loaded using `numeral.<span class="apidocCodeKeywordSpan">register</span
>(type, name, {})`

Breaking change: All `language` now renamed to `locale` and standardized to all lowercase filenames

Breaking change: The `locale` function no longer loads locales, it only sets the current locale

Breaking change: The `unformat` function has been removed `numeral().unformat(string)` and now happens on numeral init `numeral(
string)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.reset" id="apidoc.element.numeral.numeral.reset">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    for (var property in defaults) {
        options[property] = defaults[property];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.validate" id="apidoc.element.numeral.numeral.validate">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>validate
        <span class="apidocSignatureSpan">(val, culture)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (val, culture) {
    var _decimalSep,
        _thousandSep,
        _currSymbol,
        _valArray,
        _abbrObj,
        _thousandRegEx,
        localeData,
        temp;

    //coerce val to string
    if (typeof val !== &#x27;string&#x27;) {
        val += &#x27;&#x27;;

        if (console.warn) {
            console.warn(&#x27;Numeral.js: Value is not string. It has been co-erced to: &#x27;, val);
        }
    }

    //trim whitespaces from either sides
    val = val.trim();

    //if val is just digits return true
    if (!!val.match(/^\d+$/)) {
        return true;
    }

    //if val is empty return false
    if (val === &#x27;&#x27;) {
        return false;
    }

    //get the decimal and thousands separator from numeral.localeData
    try {
        //check if the culture is understood by numeral. if not, default it to current locale
        localeData = numeral.localeData(culture);
    } catch (e) {
        localeData = numeral.localeData(numeral.locale());
    }

    //setup the delimiters and currency symbol based on culture/locale
    _currSymbol = localeData.currency.symbol;
    _abbrObj = localeData.abbreviations;
    _decimalSep = localeData.delimiters.decimal;
    if (localeData.delimiters.thousands === &#x27;.&#x27;) {
        _thousandSep = &#x27;\\.&#x27;;
    } else {
        _thousandSep = localeData.delimiters.thousands;
    }

    // validating currency symbol
    temp = val.match(/^[^\d]+/);
    if (temp !== null) {
        val = val.substr(1);
        if (temp[0] !== _currSymbol) {
            return false;
        }
    }

    //validating abbreviation symbol
    temp = val.match(/[^\d]+$/);
    if (temp !== null) {
        val = val.slice(0, -1);
        if (temp[0] !== _abbrObj.thousand &#x26;&#x26; temp[0] !== _abbrObj.million &#x26;&#x26; temp[0] !== _abbrObj.billion &#x26;&#x26; temp[0] !== _abbrObj
.trillion) {
            return false;
        }
    }

    _thousandRegEx = new RegExp(_thousandSep + &#x27;{2}&#x27;);

    if (!val.match(/[^\d.,]/g)) {
        _valArray = val.split(_decimalSep);
        if (_valArray.length &#x3e; 2) {
            return false;
        } else {
            if (_valArray.length &#x3c; 2) {
                return ( !! _valArray[0].match(/^\d+.*\d$/) &#x26;&#x26; !_valArray[0].match(_thousandRegEx));
            } else {
                if (_valArray[0].length === 1) {
                    return ( !! _valArray[0].match(/^\d+$/) &#x26;&#x26; !_valArray[0].match(_thousandRegEx) &#x26;&#x26; !! _valArray[1].match(/^\d
+$/));
                } else {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) &#x26;&#x26; !_valArray[0].match(_thousandRegEx) &#x26;&#x26; !! _valArray[1].match(/^\d+$/));
                }
            }
        }
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.numeral.numeral.zeroFormat" id="apidoc.element.numeral.numeral.zeroFormat">
        function <span class="apidocSignatureSpan">numeral.numeral.</span>zeroFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroFormat = function (format) {
    options.zeroFormat = typeof(format) === &#x27;string&#x27; ? format : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
